package nng.platform;
import org.bridj.BridJ;
import org.bridj.CRuntime;
import org.bridj.Callback;
import org.bridj.Pointer;
import org.bridj.ann.Library;
import org.bridj.ann.Name;
import org.bridj.ann.Ptr;
import org.bridj.ann.Runtime;
/**
 * Wrapper for library <b>platform</b><br>
 * This file was autogenerated by <a href="https://github.com/nativelibs4java/JNAerator">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="https://github.com/nativelibs4java">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("platform") 
@Runtime(CRuntime.class) 
public class PlatformLibrary {
	static {
		BridJ.register();
	}
	/** <i>native declaration : supplemental/util/platform.h:81</i> */
	public static abstract class NngThreadCreateArg1Callback extends Callback<NngThreadCreateArg1Callback > {
		public void apply(Pointer<? > voidPtr1) {
			apply(Pointer.getPeer(voidPtr1));
		}
		public void apply(@Ptr long voidPtr1) {
			apply(Pointer.pointerToAddress(voidPtr1));
		}
	};
	/**
	 * system clock.  (Do not use it for fine grained performance measurements.)<br>
	 * Original signature : <code>nng_time nng_clock()</code><br>
	 * <i>native declaration : supplemental/util/platform.h:7</i>
	 */
	@Name("nng_clock") 
	public static native long nngClock();
	/**
	 * Sleep for specified msecs.<br>
	 * Original signature : <code>void nng_msleep()</code><br>
	 * <i>native declaration : supplemental/util/platform.h:12</i>
	 */
	@Name("nng_msleep") 
	public static native void nngMsleep();
	/**
	 * I/O APIs provided by nng.  The thread runs until completion.<br>
	 * Original signature : <code>int nng_thread_create(nng_thread**, NngThreadCreateArg1Callback*, void*)</code><br>
	 * <i>native declaration : supplemental/util/platform.h:19</i>
	 */
	@Name("nng_thread_create") 
	public static int nngThreadCreate(Pointer<Pointer<PlatformLibrary.nng_thread > > nng_threadPtrPtr1, Pointer<PlatformLibrary.NngThreadCreateArg1Callback > arg1, Pointer<? > voidPtr1) {
		return nngThreadCreate(Pointer.getPeer(nng_threadPtrPtr1), Pointer.getPeer(arg1), Pointer.getPeer(voidPtr1));
	}
	@Name("nng_thread_create") 
	protected native static int nngThreadCreate(@Ptr long nng_threadPtrPtr1, @Ptr long arg1, @Ptr long voidPtr1);
	/**
	 * returns all resources for the thread are cleaned up.<br>
	 * Original signature : <code>void nng_thread_destroy(nng_thread*)</code><br>
	 * <i>native declaration : supplemental/util/platform.h:24</i>
	 */
	@Name("nng_thread_destroy") 
	public static void nngThreadDestroy(Pointer<PlatformLibrary.nng_thread > nng_threadPtr1) {
		nngThreadDestroy(Pointer.getPeer(nng_threadPtr1));
	}
	@Name("nng_thread_destroy") 
	protected native static void nngThreadDestroy(@Ptr long nng_threadPtr1);
	/**
	 * nng_mtx_alloc allocates a mutex structure.<br>
	 * Original signature : <code>int nng_mtx_alloc(nng_mtx**)</code><br>
	 * <i>native declaration : supplemental/util/platform.h:31</i>
	 */
	@Name("nng_mtx_alloc") 
	public static int nngMtxAlloc(Pointer<Pointer<PlatformLibrary.nng_mtx > > nng_mtxPtrPtr1) {
		return nngMtxAlloc(Pointer.getPeer(nng_mtxPtrPtr1));
	}
	@Name("nng_mtx_alloc") 
	protected native static int nngMtxAlloc(@Ptr long nng_mtxPtrPtr1);
	/**
	 * nng_mtx_free frees the mutex.  It most not be locked.<br>
	 * Original signature : <code>void nng_mtx_free(nng_mtx*)</code><br>
	 * <i>native declaration : supplemental/util/platform.h:36</i>
	 */
	@Name("nng_mtx_free") 
	public static void nngMtxFree(Pointer<PlatformLibrary.nng_mtx > nng_mtxPtr1) {
		nngMtxFree(Pointer.getPeer(nng_mtxPtr1));
	}
	@Name("nng_mtx_free") 
	protected native static void nngMtxFree(@Ptr long nng_mtxPtr1);
	/**
	 * results are undefined (a panic may occur).<br>
	 * Original signature : <code>void nng_mtx_lock(nng_mtx*)</code><br>
	 * <i>native declaration : supplemental/util/platform.h:41</i>
	 */
	@Name("nng_mtx_lock") 
	public static void nngMtxLock(Pointer<PlatformLibrary.nng_mtx > nng_mtxPtr1) {
		nngMtxLock(Pointer.getPeer(nng_mtxPtr1));
	}
	@Name("nng_mtx_lock") 
	protected native static void nngMtxLock(@Ptr long nng_mtxPtr1);
	/**
	 * call this on a mutex which is not owned by caller.<br>
	 * Original signature : <code>void nng_mtx_unlock(nng_mtx*)</code><br>
	 * <i>native declaration : supplemental/util/platform.h:46</i>
	 */
	@Name("nng_mtx_unlock") 
	public static void nngMtxUnlock(Pointer<PlatformLibrary.nng_mtx > nng_mtxPtr1) {
		nngMtxUnlock(Pointer.getPeer(nng_mtxPtr1));
	}
	@Name("nng_mtx_unlock") 
	protected native static void nngMtxUnlock(@Ptr long nng_mtxPtr1);
	/**
	 * Original signature : <code>int nng_cv_alloc(nng_cv**, nng_mtx*)</code><br>
	 * <i>native declaration : supplemental/util/platform.h:50</i>
	 */
	@Name("nng_cv_alloc") 
	public static int nngCvAlloc(Pointer<Pointer<PlatformLibrary.nng_cv > > nng_cvPtrPtr1, Pointer<PlatformLibrary.nng_mtx > nng_mtxPtr1) {
		return nngCvAlloc(Pointer.getPeer(nng_cvPtrPtr1), Pointer.getPeer(nng_mtxPtr1));
	}
	@Name("nng_cv_alloc") 
	protected native static int nngCvAlloc(@Ptr long nng_cvPtrPtr1, @Ptr long nng_mtxPtr1);
	/**
	 * nng_cv_free frees the condition variable.<br>
	 * Original signature : <code>void nng_cv_free(nng_cv*)</code><br>
	 * <i>native declaration : supplemental/util/platform.h:55</i>
	 */
	@Name("nng_cv_free") 
	public static void nngCvFree(Pointer<PlatformLibrary.nng_cv > nng_cvPtr1) {
		nngCvFree(Pointer.getPeer(nng_cvPtr1));
	}
	@Name("nng_cv_free") 
	protected native static void nngCvFree(@Ptr long nng_cvPtr1);
	/**
	 * nng_cv_wait waits until the condition variable is "signaled".<br>
	 * Original signature : <code>void nng_cv_wait(nng_cv*)</code><br>
	 * <i>native declaration : supplemental/util/platform.h:60</i>
	 */
	@Name("nng_cv_wait") 
	public static void nngCvWait(Pointer<PlatformLibrary.nng_cv > nng_cvPtr1) {
		nngCvWait(Pointer.getPeer(nng_cvPtr1));
	}
	@Name("nng_cv_wait") 
	protected native static void nngCvWait(@Ptr long nng_cvPtr1);
	/**
	 * the timeout expires.  It returns NNG_ETIMEDOUT in that case.<br>
	 * Original signature : <code>int nng_cv_until(nng_cv*, nng_time)</code><br>
	 * <i>native declaration : supplemental/util/platform.h:65</i>
	 */
	@Name("nng_cv_until") 
	public static int nngCvUntil(Pointer<PlatformLibrary.nng_cv > nng_cvPtr1, long nng_time1) {
		return nngCvUntil(Pointer.getPeer(nng_cvPtr1), nng_time1);
	}
	@Name("nng_cv_until") 
	protected native static int nngCvUntil(@Ptr long nng_cvPtr1, long nng_time1);
	/**
	 * nng_cv_wake wakes all threads waiting on the condition.<br>
	 * Original signature : <code>void nng_cv_wake(nng_cv*)</code><br>
	 * <i>native declaration : supplemental/util/platform.h:70</i>
	 */
	@Name("nng_cv_wake") 
	public static void nngCvWake(Pointer<PlatformLibrary.nng_cv > nng_cvPtr1) {
		nngCvWake(Pointer.getPeer(nng_cvPtr1));
	}
	@Name("nng_cv_wake") 
	protected native static void nngCvWake(@Ptr long nng_cvPtr1);
	/**
	 * that no waiter starves forvever.<br>
	 * Original signature : <code>void nng_cv_wake1(nng_cv*)</code><br>
	 * <i>native declaration : supplemental/util/platform.h:75</i>
	 */
	@Name("nng_cv_wake1") 
	public static void nngCvWake1(Pointer<PlatformLibrary.nng_cv > nng_cvPtr1) {
		nngCvWake1(Pointer.getPeer(nng_cvPtr1));
	}
	@Name("nng_cv_wake1") 
	protected native static void nngCvWake1(@Ptr long nng_cvPtr1);
	/**
	 * nng_random returns a "strong" (cryptographic sense) random number.<br>
	 * Original signature : <code>uint32_t nng_random()</code><br>
	 * <i>native declaration : supplemental/util/platform.h:80</i>
	 */
	@Name("nng_random") 
	public static native int nngRandom();
	/** Undefined type */
	public static interface nng_thread {
		
	};
	/** Undefined type */
	public static interface nng_mtx {
		
	};
	/** Undefined type */
	public static interface nng_cv {
		
	};
}
